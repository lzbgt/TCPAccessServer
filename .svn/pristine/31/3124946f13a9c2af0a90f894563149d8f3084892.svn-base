package main

import (
	//"bytes"
	"encoding/hex"
	"encoding/json"
	"fmt"
	dt "lbsas/datatypes"
	"log"
	"net"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

var GlobalStatTcp, GlobalStatTcpLast struct {
	NumPktsReceived, NumErrorRcv, NumDBMsgStored,
	NumPktsDroped, NumInvalidPkts uint64
	NPRPS, NERPS, NDSPS, NPDPS, NIVPS float32
	StartTime, LastTime, NowTime      time.Time
}

var GlobalConfigTcp struct {
	Addr, Protocol                                                        string
	StartSymbol, EndSymbol                                                byte
	ConnChainSize, ChanSize, ReaderNum, RetryNum, PacketMaxLen, WorkerNum int
	ReadTimeoutSec                                                        time.Duration
}

func TCPServer() {
	// flags
	GlobalConfigTcp.Addr = "127.0.0.1:8082"
	GlobalConfigTcp.Protocol = "tcp"
	GlobalConfigTcp.ChanSize = 100
	GlobalConfigTcp.ReaderNum = 4
	GlobalConfigTcp.RetryNum = 3
	GlobalConfigTcp.WorkerNum = 2
	GlobalConfigTcp.ReadTimeoutSec = 200
	GlobalConfigTcp.PacketMaxLen = 180
	GlobalConfigTcp.StartSymbol = '+'
	GlobalConfigTcp.EndSymbol = '$'

	// start rcv
	go func() {
		a, e := net.ResolveTCPAddr(GlobalConfigTcp.Protocol, GlobalConfigTcp.Addr)
		if e != nil {
			log.Fatal(e)
		}
		l, e := net.ListenTCP("tcp", a)
		for {
			c, e := l.Accept()
			if e != nil {
				log.Fatal(e)
			}
			// new tcp sock session
			log.Println(fmt.Sprintf("accepted: %#v", c))
			go tcpStartSession(c)
		}
	}()

	GlobalStatTcp.LastTime = time.Now()
	GlobalStatTcp.NowTime = time.Now()

	// start the embedded web server
	r := mux.NewRouter()
	r.HandleFunc("/api/{component}", _apiHandlerTcp)
	http.Handle("/", r)
	go http.ListenAndServe("127.0.0.1:9090", nil)
}

// tcp session handler
// one channel per session
func tcpStartSession(conn net.Conn) {
	defer conn.Close()
	// set read timeout
	conn.SetReadDeadline(time.Now().Add(GlobalConfigTcp.ReadTimeoutSec * time.Second))

	// channel to cache packets when the far-end device is busy sending
	packetsChan := make(chan *dt.RawTcpPacket, GlobalConfigTcp.ChanSize)
	defer close(packetsChan)

	// create a default worker
	go tcpWorker(packetsChan)

	var (
		last, n,
		numStart, numEnd int
		err  error
		buff []byte
	)

	last, n, err, buff, numStart, numEnd =
		0, 0, nil,
		make([]byte, GlobalConfigTcp.PacketMaxLen),
		0, 0

	// try to read a packet
	for {
		n, err = conn.Read(buff[last:])
		if err != nil {
			// log.Error(err)
			GlobalStatTcp.NumErrorRcv++
			break
		}

		if last == 0 && buff[0] != GlobalConfigTcp.StartSymbol {
			// invalid packet
			GlobalStatTcp.NumInvalidPkts++

			// TODO: there are two approches here:
			// 1) ignor and continue
			// 2) refuse and close
			// we chose the 1st one
			continue

			// break
		}

		// TODO: [remove me] for test with netcat
		if buff[last+n-1] == 0x0a {
			buff[last+n-1] = 0
			n--
			if n == 0 {
				continue
			}
		}

		log.Println(string(buff[:last+n]), "decoded:", hex.EncodeToString(buff[:last+n]))

		// there is remain part unread
		if !isWholePacket(buff[last:last+n], &numStart, &numEnd) {
			last += n
			// TODO: remove me
			log.Println(fmt.Sprint("not whole packet: %s", buff[:last]))
		} else {
			// we got a whole packet here
			GlobalStatTcp.NumPktsReceived++
			packet := &dt.RawTcpPacket{make([]byte, last), &conn}
			copy(packet.Buff, buff[:last+n])
			// reset counters
			n, last, numStart, numEnd = 0, 0, 0, 0

			// insert into the chan
			select {
			case packetsChan <- packet:
				log.Println(fmt.Sprint("new chan elem:%#v", packet))
			default:
				// TODO: two approches to handle this situation
				// 1) just drop the oldest msg and insert the new one
				// 2) create a now worker on the channel and insert again
				// Currently the first one is applied; the second approche can
				// be a feature in future release, and it's required
				// to release long-time-ide workers [IMPORTANT feature]

				<-packetsChan
				packetsChan <- packet
				GlobalStatTcp.NumPktsDroped++
				// TODO
				log.Println("Buff overflow in :%v", conn)
			}
		}
	}

	// teardown
	if err != nil {
		//TODO
	}
}

func tcpWorker(packetsChan chan *dt.RawTcpPacket) {
	for {
		packet := <-packetsChan

		// data packet
		log.Println(fmt.Sprint("worker on: %#v", packet))

		// handle channel close event
		if packet == nil {
			break
		}
	}
}

// helper function
// try to match num of '+' and '$'
func isWholePacket(buff []byte, nS, nE *int) bool {
	for i := 0; i < len(buff); i++ {
		switch buff[i] {
		case GlobalConfigTcp.StartSymbol:
			*nS++
		case GlobalConfigTcp.EndSymbol:
			*nE++
		}
	}
	// TODO: is there a '\0' at the end?
	log.Println("ns:", *nS, "ne:", *nE)
	return *nS == *nE && buff[len(buff)-1] == GlobalConfigTcp.EndSymbol
}

func _apiHandlerTcp(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	coapi := vars["component"]
	var ret []byte
	switch coapi {
	case "tcpstatus":
		GlobalStatTcp.LastTime = GlobalStatTcp.NowTime
		GlobalStatTcp.NowTime = time.Now()
		// NxxPS
		tdelta := float32(GlobalStatTcp.NowTime.Unix() - GlobalStatTcp.LastTime.Unix())
		GlobalStatTcp.NDSPS = (float32)(GlobalStatTcp.NumDBMsgStored-GlobalStatTcpLast.NumDBMsgStored) / tdelta
		GlobalStatTcp.NERPS = (float32)(GlobalStatTcp.NumErrorRcv-GlobalStatTcpLast.NumErrorRcv) / tdelta
		GlobalStatTcp.NPDPS = (float32)(GlobalStatTcp.NumPktsDroped-GlobalStatTcpLast.NumPktsDroped) / tdelta
		GlobalStatTcp.NPRPS = (float32)(GlobalStatTcp.NumPktsReceived-GlobalStatTcpLast.NumPktsReceived) / tdelta
		GlobalStatTcp.NIVPS = (float32)(GlobalStatTcp.NumInvalidPkts-GlobalStatTcpLast.NumInvalidPkts) / tdelta

		// NumxxLast
		GlobalStatTcpLast.NumDBMsgStored = GlobalStatTcp.NumDBMsgStored
		GlobalStatTcpLast.NumErrorRcv = GlobalStatTcp.NumErrorRcv
		GlobalStatTcpLast.NumPktsDroped = GlobalStatTcp.NumPktsDroped
		GlobalStatTcpLast.NumPktsReceived = GlobalStatTcp.NumPktsReceived
		GlobalStatTcpLast.NumInvalidPkts = GlobalStatTcp.NumInvalidPkts

		//
		GlobalStatTcpLast.LastTime = GlobalStatTcp.LastTime
		ret, _ = json.Marshal(GlobalStatTcp)
	default:
		ret = []byte("{\"failed\":true, \"msg\":\"unknown api\"}")

	}
	fmt.Println("web")

	w.Header().Set("Content-Type", "application/json")
	w.Write(ret)
}
