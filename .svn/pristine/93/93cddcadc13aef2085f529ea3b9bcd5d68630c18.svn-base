package database

import (
	"database/sql"
	. "lbsas/datatypes"
	"lbsas/utils"

	log "github.com/Sirupsen/logrus"

	_ "github.com/go-sql-driver/mysql"
)

type DbHelper struct {
	db       *sql.DB
	ImeiToId map[string]string
	IdToImei map[string]string
}

func (s *DbHelper) SetDb(db *sql.DB) {
	s.db = db
}

func (s *DbHelper) Close() {
	if s.db != nil {
		s.db.Close()
		s.db = nil
	}
}

func (s *DbHelper) GetImeiById(id string) (string, error) {
	if imei, ok := s.IdToImei[id]; ok {
		return imei, nil
	} else {
		rows, err := s.db.Query("select id, deviceImei from device where id=?", id)
		if err != nil {
			log.Error(err, id)
		}

		defer rows.Close()
		var (
			id         string
			deviceImei string
		)
		if rows.Next() {
			err := rows.Scan(&id, &deviceImei)
			if err != nil {
				log.Error(err)
			}
			s.IdToImei[id] = deviceImei
			s.ImeiToId[deviceImei] = id
		} else {
			return "no such device", sql.ErrNoRows
		}
		err = rows.Err()
		if err != nil {
			log.Error(err)
		}
		return deviceImei, nil
	}
}

func (s *DbHelper) GetIdByImei(imei string) (string, error) {
	if id, ok := s.ImeiToId[imei]; ok {
		return id, nil
	} else {
		rows, err := s.db.Query("select id, deviceImei from device where deviceImei=?", id)
		if err != nil {
			log.Error(err, imei)
		}

		defer rows.Close()
		var (
			id         string
			deviceImei string
		)
		if rows.Next() {
			err := rows.Scan(&id, &deviceImei)
			if err != nil {
				log.Error(err)
			}
			s.IdToImei[id] = deviceImei
			s.ImeiToId[deviceImei] = id
		} else {
			return "no such device", sql.ErrNoRows
		}

		return id, rows.Err()
	}
}

func (s *DbHelper) SaveEventData(repo *MessageResp) error {

	id, err := s.GetIdByImei(string(repo.UID))
	if err != nil {
		return err
	}

	tm := utils.GetTimestampFromString(repo.GPSUTime).UnixNano() / 1000000

	log.Debug("SaveEventData: deviceId=", id, ", tm=", tm)

	sqlStr := `INSERT INTO eventdata(deviceId, timestamp, 
	     latitude, longitude, speed, heading) VALUES(?,?,?,?,?,?)`
	stmt, err := s.db.Prepare(sqlStr)
	if err != nil {
		return err
	}
	res, err := stmt.Exec(id, tm, repo.Latitude, repo.Longitude, repo.Speed, repo.Azimuth)
	if err != nil {
		return err
	}

	lastId, err := res.LastInsertId()
	if err != nil {
		return err
	}
	rowCnt, err := res.RowsAffected()
	log.Debug("ID =", lastId, "affected =", rowCnt)

	return err
}

//deviceId, lastAckTime, latitude,longitude ,speed ,heading ,gpsTimestamp ,updateTime
func (s *DbHelper) UpdateLatestData(repo *MessageResp) error {

	id, err := s.GetIdByImei(string(repo.UID))
	if err != nil {
		return err
	}
	tm := utils.GetTimestampFromString(repo.GPSUTime).UnixNano() / 1000000

	log.Debug("UpdateLatestData: deviceId=", id, ", tm=", tm)

	stmt, err := s.db.Prepare(`UPDATE devicelatestdata SET lastAckTime=?, 
	    latitude=?, longitude=?, speed=?, heading=?, gpsTimestamp=?, updateTime=? where deviceId=?`)
	if err != nil {
		return err
	}
	res, err := stmt.Exec(tm, repo.Latitude, repo.Longitude, repo.Speed, repo.Azimuth, tm, tm, id)
	if err != nil {
		return err
	}

	lastId, err := res.LastInsertId()
	if err != nil {
		return err
	}
	rowCnt, err := res.RowsAffected()
	if err != nil {
		return err
	}
	log.Debug("ID =", lastId, "affected =", rowCnt)
	return nil
}

//user:password@tcp(127.0.0.1:3306)/hello
func New(conf string, logLevel log.Level) (*DbHelper, error) {
	log.SetLevel(logLevel)
	log.SetFormatter(&log.TextFormatter{})

	helper := &DbHelper{IdToImei: make(map[string]string), ImeiToId: make(map[string]string)}
	db, err := sql.Open("mysql", conf)
	helper.SetDb(db)
	if err != nil {
		return nil, err
	}

	//populate maps
	sqlStr := "select id, deviceImei from device"
	rows, err := db.Query(sqlStr)
	if err != nil {
		return nil, err
	}

	defer rows.Close()
	var (
		id         string
		deviceImei string
	)
	for rows.Next() {
		err := rows.Scan(&id, &deviceImei)
		if err != nil {
			break
		}
		log.Debug(id, deviceImei)
		helper.IdToImei[id] = deviceImei
		helper.ImeiToId[deviceImei] = id
	}
	err = rows.Err()
	if err != nil {
		log.Error(err, ", SQL:", sqlStr)
	}

	//
	return helper, err
}
