package datatypes

import (
	"errors"
	"net"
	"reflect"
	"time"

	log "github.com/Sirupsen/logrus"
)

var ErrorMessage = map[string]error{
	"INVALID_PACKET_HT":  errors.New("start/end symbol in packet is invalid"),
	"INVALID_PACKET_LEN": errors.New("invalid packet length or num of fields"),
}

type RawUdpPacket struct {
	Buff    [80]byte
	Size    int
	Remote  *net.UDPAddr
	UdpConn *net.UDPConn
}

type RawTcpPacket struct {
	Buff []byte
	Conn *net.Conn
}

type MessageResp struct {
	Command, //10
	Version, //6
	UID, //15, XX0000-XX-FFFF
	Name, //10, IMEI
	RID, //1, 0-4
	RType, //1, 0|1
	MoveStat, //1, 0|1|2
	Temperature, //4, xx.x
	BattPecent, //3, 0-100
	GPSAccuracy, //<=2, 0|1-50
	Speed, //<=5, 0.0-999.9km/h
	Azimuth, //<=3, 0-359
	Altitude, //<=8, -xxxxx.x
	Longitude, //<=11, -xxx.xxxxx
	Latitude, //<=10, -xx.xxxxxx
	GPSUTime, //14, YYYYMMDDHHMMSS
	MCC, //4, 0XXX
	MNC, //4, 0XXX
	LAC, //4, XXXX
	CID, //4, XXXX
	R1, //0
	R2,
	R3,
	SendTime, //14
	SeqNum []byte //4, 0000-FFFF
}

func (m *MessageResp) LogContent() {
	val := reflect.ValueOf(m).Elem()
	typ := reflect.TypeOf(m).Elem()
	for i := 0; i < val.NumField(); i++ {
		log.Debug(typ.Field(i).Name, string(val.Field(i).Bytes()))
	}
}

func (m *MessageResp) Validate() error {
	return nil
}

func (m *MessageResp) Parse(parts []string, conn *net.Conn) bool {
	log.Debug(reflect.TypeOf(m).String(), "paser called")
	val := reflect.ValueOf(m).Elem()
	if len(parts) != val.NumField() {
		log.Error(ErrorMessage["INVALID_PACKET_LEN"], ", From ", (*conn).RemoteAddr())
		return false
	}
	for i := 0; i < val.NumField(); i++ {
		valueField := val.Field(i)
		valueField.SetBytes([]byte(parts[i]))
	}

	// remove me
	if log.GetLevel() == log.DebugLevel {
		m.LogContent()
	}

	{
		err := m.Validate()
		if err != nil {
			log.Error("ERROR", err, ", Buff:", parts, ", From:", (*conn).RemoteAddr())
			return false
		}
	}

	return true
}

type EnviromentCfg struct {
	DBMaxOpenConns, DBMaxIdleConns,
	QueueSizePerConn, NumWorkersPerConn, TCPTimeOutSec int
	LogLevel                  log.Level
	TCPAddr, HTTPAddr, DBAddr string
	DBProf                    bool
}

type TCPCfg struct {
	// config
	Addr, Protocol, HttpAddr, DBAddr                                      string
	StartSymbol, EndSymbol                                                byte
	ConnChainSize, ChanSize, ReaderNum, RetryNum, PacketMaxLen, WorkerNum int
	ReadTimeoutSec                                                        time.Duration
	LogLevel                                                              log.Level
	// stat
	AvgWorkerTimeMicroSec, AvgDBTimeMicroSec int64
	NumInvalidPackets                        int64
}

type Vendor interface {
	GetCfg() *TCPCfg
	TcpWorker(packetsChan chan *RawTcpPacket)
	HandlePacket(packet *RawTcpPacket) bool
	ParseMessage(parts []string, conn *net.Conn) interface{}
	IsWholePacket(buff []byte, whole *bool) (bool, error)
}

type TCPStat struct {
	NumConnActive, NumConnCreated, NumConnClosed, NumPktsReceived, NumErrorRcv, NumDBMsgStored,
	NumPktsDroped, NumInvalidPkts uint64
	NumConnCreatedPS, NumConnClosedPS, NumPktsReceivedPS, NumErrorRcvPS, NumDBMsgStoredPS,
	NumPktsDropedPS, NumInvalidPktsPS,
	MaxNumConnCreatedPS, MaxNumConnClosedPS, MaxNumPktsReceivedPS, MaxNumErrorRcvPS, MaxNumDBMsgStoredPS,
	MaxNumPktsDropedPS, MaxNumInvalidPktsPS float32
	AvgWorkerTimeMicroSec, AvgDBTimeMicroSec int64
	NumInvalidPackets                        int64
	StartTime, LastTime, NowTime             time.Time
}
