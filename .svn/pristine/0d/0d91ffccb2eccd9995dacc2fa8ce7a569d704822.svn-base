package nbsihai

import (
	"bytes"
	dbh "lbsas/database"
	. "lbsas/datatypes"
	gcj "lbsas/gcj02"
	"net"
	"strconv"
	"strings"
	"time"

	log "github.com/Sirupsen/logrus"
)

// module exported globals
type NbSiHai struct {
	TcpConfig TCPCfg
	*dbh.DbHelper
}

// module private globals
var _MessageConstants = &struct {
	ClassReport, ClassAT, ClassACK, ClassBuff string
	Commands                                  map[string]interface{}
	Delimiter                                 byte
}{
	"RESP:", "AT+", "ACK:", "BUFF:",
	map[string]interface{}{
		"RESP:GTCTN": MessageResp{},
		"RESP:GTSTR": MessageResp{},
		"RESP:GTRTL": MessageResp{},
		"RESP:GTBL":  MessageResp{},
		"BUFF:GTCTN": MessageResp{},
		"BUFF:GTSTR": MessageResp{},
		"BUFF:GTRTL": MessageResp{},
	},
	byte(','),
}

func New(env *EnviromentCfg) *NbSiHai {
	log.SetLevel(env.LogLevel)
	dbHelper, err := dbh.New(env)
	if err != nil {
		log.Fatal(err)
	}
	return &NbSiHai{
		TCPCfg{ // flags
			Addr:           env.TCPAddr,
			HttpAddr:       env.HTTPAddr,
			Protocol:       "tcp",
			ChanSize:       env.QueueSizePerConn,
			ReaderNum:      4,
			RetryNum:       3,
			WorkerNum:      env.NumWorkersPerConn,
			ReadTimeoutSec: time.Duration(env.TCPTimeOutSec),
			PacketMaxLen:   180,
			StartSymbol:    '+',
			EndSymbol:      '$',
			LogLevel:       env.LogLevel,
			DBAddr:         env.DBAddr,
		},
		dbHelper,
	}
}

func (s *NbSiHai) TcpWorker(packetsChan chan *RawTcpPacket) {
	for {
		timeLast := time.Now()
		packet := <-packetsChan
		delta := (time.Now().UnixNano() - timeLast.UnixNano()) / 1000
		if s.TcpConfig.AvgWaitMicroSec == 0 {
			s.TcpConfig.AvgWaitMicroSec = delta
		} else {
			s.TcpConfig.AvgWaitMicroSec = (s.TcpConfig.AvgWaitMicroSec + delta) / 2
		}

		success := false

		// handle channel close event
		if packet == nil {
			log.Info("nil packet, close connection")
			break
		} else {
			// data packet
			if success = s.HandlePacket(packet); !success {
				s.TcpConfig.NumInvalidPackets++
				continue
			}
		}
		// micro sec
		delta := (time.Now().UnixNano() - timeLast.UnixNano()) / 1000
		if s.TcpConfig.AvgWorkerTimeMicroSec == 0 {
			s.TcpConfig.AvgWorkerTimeMicroSec = delta
		} else {
			s.TcpConfig.AvgWorkerTimeMicroSec = (s.TcpConfig.AvgWorkerTimeMicroSec + delta) / 2
		}
	}
}

func (s *NbSiHai) HandlePacket(packet *RawTcpPacket) bool {
	buff := packet.Buff[1 : len(packet.Buff)-1]
	if len(buff) == 0 {
		log.Info("invalid packet, ignored")
		return false
	}

	//split
	var sep bytes.Buffer
	sep.WriteByte(s.TcpConfig.EndSymbol)
	sep.WriteByte(s.TcpConfig.StartSymbol)
	messages := strings.Split(string(buff), sep.String())

	for _, v := range messages {
		parts := strings.Split(v, string(_MessageConstants.Delimiter))
		s.ParseMessage(parts, packet.Conn)
	}

	return true
}

func (s *NbSiHai) ParseMessage(parts []string, conn *net.Conn) interface{} {
	var err error = nil
	var lat, lng float64
	if par := _MessageConstants.Commands[parts[0]]; par != nil {
		switch par.(type) {
		case MessageResp:
			_par := par.(MessageResp)
			if _par.Parse(parts, conn) {
				// convert WGS to GCJ-02
				lat, err = strconv.ParseFloat(string(_par.Latitude), 64)
				if err == nil {
					lng, err = strconv.ParseFloat(string(_par.Longitude), 64)
					if err == nil {
						lat, lng = gcj.WGStoBD(lat, lng)
						_par.Latitude = []byte(strconv.FormatFloat(lat, 'f', 6, 64))
						_par.Longitude = []byte(strconv.FormatFloat(lng, 'f', 6, 64))
					}
				}

				timeLast := time.Now()
				if err == nil {
					err = s.SaveEventData(&_par)
					if err == nil {
						err = s.UpdateLatestData(&_par)
					}
				}

				if err != nil {
					log.Error(err, ", Buff:", parts, ", From:", (*conn).RemoteAddr())
				} else {
					// micro sec
					delta := (time.Now().UnixNano() - timeLast.UnixNano()) / 1000
					if s.TcpConfig.AvgDBTimeMicroSec == 0 {
						s.TcpConfig.AvgDBTimeMicroSec = delta
					} else {
						s.TcpConfig.AvgDBTimeMicroSec = (s.TcpConfig.AvgDBTimeMicroSec + delta) / 2
					}
				}
			}
		default:
			log.Error("unkown message", parts, "From", (*conn).RemoteAddr().String())
		}
	} else {
		log.Error("unkown cmd", parts, "From", (*conn).RemoteAddr().String())
	}

	return nil
}

// helper function
// try to match '+' and '$'
func (s *NbSiHai) IsWholePacket(buff []byte, whole *bool) (bool, error) {
	for i := 0; i < len(buff); i++ {
		switch buff[i] {
		case s.TcpConfig.StartSymbol:
			if *whole == false {
				return false, ErrorMessage["INVALID_PACKET_HT"]
			}
			*whole = false
		case s.TcpConfig.EndSymbol:
			if *whole == true {
				return false, ErrorMessage["INVALID_PACKET_HT"]
			}
			*whole = true
		}
	}
	// TODO: is there a '\0' at the end?
	return *whole && buff[len(buff)-1] == s.TcpConfig.EndSymbol, nil
}

func (s *NbSiHai) GetCfg() *TCPCfg {
	return &(s.TcpConfig)
}
