package tcp

import (
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	. "lbsas/datatypes"
	"net"
	"net/http"
	"os"
	"time"

	log "github.com/Sirupsen/logrus"
	"github.com/gorilla/mux"
)

// globals
type TCPServer struct {
	StatTcp, StatTcpLast TCPStat
	v                    Vendor
	Reportor             *log.Logger
}

// main
func New(v Vendor) *TCPServer {
	reportor := log.New()
	reportor.Level = log.DebugLevel
	f, err := os.Create("report.log")
	if err != nil {
		log.Fatal(err)
	}
	reportor.Out = f
	log.SetLevel(v.GetCfg().LogLevel)
	log.SetFormatter(&log.TextFormatter{})

	ret := &TCPServer{TCPStat{}, TCPStat{}, v, reportor}

	// log.SetFlags(log.Lshortfile | log.Ldate | log.Ltime)
	// start receiving
	go func() {
		a, e := net.ResolveTCPAddr(v.GetCfg().Protocol, v.GetCfg().Addr)
		if e != nil {
			log.Fatal(e)
		}
		l, e := net.ListenTCP(v.GetCfg().Protocol, a)
		for {
			c, e := l.Accept()
			if e != nil {
				log.Error(e)
			}
			// new tcp sock session
			ret.StatTcp.NumConnCreated++
			log.Debug("accepted:", c.RemoteAddr().String())
			go ret.tcpStartSession(c)
		}
	}()

	// code for statistics, just skip these
	ret.StatTcp.LastTime = time.Now()
	ret.StatTcp.NowTime = ret.StatTcp.LastTime
	ret.StatTcp.StartTime = ret.StatTcp.LastTime
	ret.StatTcpLast.LastTime = ret.StatTcp.LastTime
	ret.StatTcpLast.NowTime = ret.StatTcp.LastTime
	ret.StatTcpLast.StartTime = ret.StatTcp.LastTime

	// start the embedded web server
	r := mux.NewRouter()
	r.HandleFunc("/api/{component}", ret._apiHandlerTcp)
	http.Handle("/", r)
	go http.ListenAndServe(v.GetCfg().HttpAddr, nil)

	return ret
}

// tcp session handler
func (s *TCPServer) tcpStartSession(conn net.Conn) {
	defer conn.Close()

	// channel to cache packets when the far-end device is busy sending
	packetsChan := make(chan *RawTcpPacket, s.v.GetCfg().ChanSize)
	defer close(packetsChan)

	// create a default worker
	go s.v.TcpWorker(packetsChan)

	var (
		last, n int
		whole   bool
		err     error
		buff    []byte
	)

	last, n, err, buff, whole =
		0, 0, nil,
		make([]byte, s.v.GetCfg().PacketMaxLen), true

	// try to read a packet
	for {
		// set read timeout
		conn.SetReadDeadline(time.Now().Add(s.v.GetCfg().ReadTimeoutSec * time.Second))
		n, err = conn.Read(buff[last:])
		if err != nil {
			s.StatTcp.NumErrorRcv++
			break
		}

		if last == 0 && buff[0] != s.v.GetCfg().StartSymbol {
			// invalid packet
			s.StatTcp.NumInvalidPkts++

			// TODO: there are two approches here:
			// 1) ignor and continue
			// 2) refuse and close
			// we chose the 2nd one
			//continue
			err = ErrorMessage["INVALID_PACKET_HT"]
			err = errors.New(fmt.Sprint(err.Error(), ", Buff:", string(buff[:last+n]),
				", From:", conn.RemoteAddr()))
			break
		}

		// TODO: [remove me] for test with netcat/telnet
		if buff[last+n-1] == 0x0a {
			buff[last+n-1] = 0
			n--
			if n == 0 {
				continue
			}
		}

		log.Debug(string(buff[:last+n]), "decoded:", hex.EncodeToString(buff[:last+n]))

		// there is remain part unread
		whole, err = s.v.IsWholePacket(buff[last:last+n], &whole)
		if err != nil {
			s.StatTcp.NumInvalidPkts++
			// Invalid packet
			err = errors.New(fmt.Sprint(err.Error(), ", Buff:", string(buff[:last+n]),
				", From:", conn.RemoteAddr()))
			break
		} else if !whole {
			last += n
			log.Debug("not whole packet:", string(buff[:last]))
		} else {
			// we got a whole peacket here
			s.StatTcp.NumPktsReceived++
			packet := &RawTcpPacket{make([]byte, last+n), &conn}
			copy(packet.Buff, buff[:last+n])
			// reset counters
			n, last, whole = 0, 0, true

			// insert into the chan
			select {
			case packetsChan <- packet:
			default:
				// TODO: two approches to handle this situation
				// 1) just drop the oldest msg and insert the new one
				// 2) create a now worker on the channel and insert again
				// Currently the first one is applied; the second approche can
				// be a feature in future release, and it's required
				// to release long-time-ide workers [IMPORTANT feature]

				<-packetsChan
				packetsChan <- packet
				s.StatTcp.NumPktsDroped++
				// TODO
				log.Error("Buff overflow. From:", conn.RemoteAddr(), ", Buff size:", s.v.GetCfg().ChanSize)
			}
		}
	}

	// teardown
	// we are not interested in EOF
	if err != nil && err.Error() != "EOF" {
		log.Error(err)
	}
	s.StatTcp.NumConnClosed++
}

// code for statistics, just skip it
func (s *TCPServer) _apiHandlerTcp(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	coapi := vars["component"]
	var ret []byte
	switch coapi {
	case "tcpstatus":
		temp := s.StatTcp

		s.StatTcpLast.LastTime = s.StatTcpLast.NowTime
		s.StatTcpLast.NowTime = time.Now()
		// NxxPS
		tdelta := float32(s.StatTcpLast.NowTime.Unix() - s.StatTcpLast.LastTime.Unix())
		s.StatTcpLast.NumDBMsgStoredPS = (float32)(temp.NumDBMsgStored-s.StatTcpLast.NumDBMsgStored) / tdelta
		s.StatTcpLast.NumErrorRcvPS = (float32)(temp.NumErrorRcv-s.StatTcpLast.NumErrorRcv) / tdelta
		s.StatTcpLast.NumPktsDropedPS = (float32)(temp.NumPktsDroped-s.StatTcpLast.NumPktsDroped) / tdelta
		s.StatTcpLast.NumPktsReceivedPS = (float32)(temp.NumPktsReceived-s.StatTcpLast.NumPktsReceived) / tdelta
		s.StatTcpLast.NumInvalidPktsPS = (float32)(temp.NumInvalidPkts-s.StatTcpLast.NumInvalidPkts) / tdelta
		s.StatTcpLast.NumConnClosedPS = (float32)(temp.NumConnClosed-s.StatTcpLast.NumConnClosed) / tdelta
		s.StatTcpLast.NumConnCreatedPS = (float32)(temp.NumConnCreated-s.StatTcpLast.NumConnCreated) / tdelta

		// max
		//

		// NumxxLast
		s.StatTcpLast.NumDBMsgStored = temp.NumDBMsgStored
		s.StatTcpLast.NumErrorRcv = temp.NumErrorRcv
		s.StatTcpLast.NumPktsDroped = temp.NumPktsDroped
		s.StatTcpLast.NumPktsReceived = temp.NumPktsReceived
		s.StatTcpLast.NumInvalidPkts = temp.NumInvalidPkts
		s.StatTcpLast.NumConnClosed = temp.NumConnClosed
		s.StatTcpLast.NumConnCreated = temp.NumConnCreated

		//
		s.StatTcpLast.AvgWorkerTimeMicroSec = s.v.GetCfg().AvgWorkerTimeMicroSec
		s.StatTcpLast.AvgDBTimeMicroSec = s.v.GetCfg().AvgDBTimeMicroSec
		s.StatTcpLast.NumInvalidPackets = s.v.GetCfg().NumInvalidPackets

		//
		ret, _ = json.Marshal(s.StatTcpLast)
	default:
		ret = []byte("{\"failed\":true, \"msg\":\"unknown api\"}")

	}
	if w == nil && r == nil {
		// write to database
		s.Reportor.Println(ret)
	} else {
		w.Header().Set("Content-Type", "application/json")
		w.Write(ret)
	}

	log.Debug(string(ret))
}

// timer triggered every 10s to report statistics
func (s *TCPServer) statusReport() {
	timeChan := time.NewTimer(time.Second * 10).C
	for {
		<-timeChan
		s._apiHandlerTcp(nil, nil)
	}
}
