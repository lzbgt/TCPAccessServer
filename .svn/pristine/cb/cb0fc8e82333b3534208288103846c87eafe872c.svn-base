package tcp

import (
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	. "lbsas/datatypes"
	"net"
	"net/http"
	"time"

	log "github.com/Sirupsen/logrus"

	"github.com/gorilla/mux"
)

// globals
type TCPServer struct {
	GlobalStatTcp, GlobalStatTcpLast TCPStat
	v                                Vendor
}

// main
func New(v Vendor, lv log.Level) *TCPServer {
	log.SetLevel(lv)
	log.SetFormatter(&log.TextFormatter{})
	v.SetLogLevel(lv)

	ret := &TCPServer{TCPStat{}, TCPStat{}, v}

	// log.SetFlags(log.Lshortfile | log.Ldate | log.Ltime)
	// start receiving
	go func() {
		a, e := net.ResolveTCPAddr(v.GetCfg().Protocol, v.GetCfg().Addr)
		if e != nil {
			log.Fatal(e)
		}
		l, e := net.ListenTCP(v.GetCfg().Protocol, a)
		for {
			c, e := l.Accept()
			if e != nil {
				log.Fatal(e)
			}
			// new tcp sock session
			ret.GlobalStatTcp.NumConnCreated++
			log.Debug("accepted:", c.RemoteAddr().String())
			go ret.tcpStartSession(c)
		}
	}()

	// code for statistics, just skip these
	ret.GlobalStatTcp.LastTime = time.Now()
	ret.GlobalStatTcp.NowTime = ret.GlobalStatTcp.LastTime
	ret.GlobalStatTcp.StartTime = ret.GlobalStatTcp.LastTime
	ret.GlobalStatTcpLast.LastTime = ret.GlobalStatTcp.LastTime
	ret.GlobalStatTcpLast.NowTime = ret.GlobalStatTcp.LastTime
	ret.GlobalStatTcpLast.StartTime = ret.GlobalStatTcp.LastTime

	// start the embedded web server
	r := mux.NewRouter()
	r.HandleFunc("/api/{component}", ret._apiHandlerTcp)
	http.Handle("/", r)
	go http.ListenAndServe("127.0.0.1:9090", nil)

	return ret
}

// tcp session handler
func (s *TCPServer) tcpStartSession(conn net.Conn) {
	defer conn.Close()

	// channel to cache packets when the far-end device is busy sending
	packetsChan := make(chan *RawTcpPacket, s.v.GetCfg().ChanSize)
	defer close(packetsChan)

	// create a default worker
	go s.v.TcpWorker(packetsChan)

	var (
		last, n int
		whole   bool
		err     error
		buff    []byte
	)

	last, n, err, buff, whole =
		0, 0, nil,
		make([]byte, s.v.GetCfg().PacketMaxLen), true

	// try to read a packet
	for {
		// set read timeout
		conn.SetReadDeadline(time.Now().Add(s.v.GetCfg().ReadTimeoutSec * time.Second))
		n, err = conn.Read(buff[last:])
		if err != nil {
			s.GlobalStatTcp.NumErrorRcv++
			break
		}

		if last == 0 && buff[0] != s.v.GetCfg().StartSymbol {
			// invalid packet
			s.GlobalStatTcp.NumInvalidPkts++

			// TODO: there are two approches here:
			// 1) ignor and continue
			// 2) refuse and close
			// we chose the 2nd one
			//continue
			err = ErrorMessage["INVALID_PACKET_HT"]
			err = errors.New(fmt.Sprint(err.Error(), ", Buff:", string(buff[:last+n]),
				", From:", conn.RemoteAddr()))
			break
		}

		// TODO: [remove me] for test with netcat/telnet
		if buff[last+n-1] == 0x0a {
			buff[last+n-1] = 0
			n--
			if n == 0 {
				continue
			}
		}

		log.Debug(string(buff[:last+n]), "decoded:", hex.EncodeToString(buff[:last+n]))

		// there is remain part unread
		whole, err = s.v.IsWholePacket(buff[last:last+n], &whole)
		if err != nil {
			s.GlobalStatTcp.NumInvalidPkts++
			// Invalid packet
			err = errors.New(fmt.Sprint(err.Error(), ", Buff:", string(buff[:last+n]),
				", From:", conn.RemoteAddr()))
			break
		} else if !whole {
			last += n
			log.Debug("not whole packet:", string(buff[:last]))
		} else {
			// we got a whole peacket here
			s.GlobalStatTcp.NumPktsReceived++
			packet := &RawTcpPacket{make([]byte, last+n), &conn}
			copy(packet.Buff, buff[:last+n])
			// reset counters
			n, last, whole = 0, 0, true

			// insert into the chan
			select {
			case packetsChan <- packet:
				// log.Debug("new chan elem:", string(packet.Buff), ", from:", (*packet.Conn).RemoteAddr().String())
			default:
				// TODO: two approches to handle this situation
				// 1) just drop the oldest msg and insert the new one
				// 2) create a now worker on the channel and insert again
				// Currently the first one is applied; the second approche can
				// be a feature in future release, and it's required
				// to release long-time-ide workers [IMPORTANT feature]

				<-packetsChan
				packetsChan <- packet
				s.GlobalStatTcp.NumPktsDroped++
				// TODO
				log.Error("Buff overflow in :%#v", conn)
			}
		}
	}

	// teardown
	// we are not interested in EOF
	if err != nil && err.Error() != "EOF" {
		log.Error(err)
	}
	s.GlobalStatTcp.NumConnClosed++
}

// code for statistics, just skip it
func (s *TCPServer) _apiHandlerTcp(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	coapi := vars["component"]
	var ret []byte
	switch coapi {
	case "tcpstatus":
		temp := s.GlobalStatTcp

		s.GlobalStatTcpLast.LastTime = s.GlobalStatTcpLast.NowTime
		s.GlobalStatTcpLast.NowTime = time.Now()
		// NxxPS
		tdelta := float32(s.GlobalStatTcpLast.NowTime.Unix() - s.GlobalStatTcpLast.LastTime.Unix())
		s.GlobalStatTcpLast.NumDBMsgStoredPS = (float32)(temp.NumDBMsgStored-s.GlobalStatTcpLast.NumDBMsgStored) / tdelta
		s.GlobalStatTcpLast.NumErrorRcvPS = (float32)(temp.NumErrorRcv-s.GlobalStatTcpLast.NumErrorRcv) / tdelta
		s.GlobalStatTcpLast.NumPktsDropedPS = (float32)(temp.NumPktsDroped-s.GlobalStatTcpLast.NumPktsDroped) / tdelta
		s.GlobalStatTcpLast.NumPktsReceivedPS = (float32)(temp.NumPktsReceived-s.GlobalStatTcpLast.NumPktsReceived) / tdelta
		s.GlobalStatTcpLast.NumInvalidPktsPS = (float32)(temp.NumInvalidPkts-s.GlobalStatTcpLast.NumInvalidPkts) / tdelta
		s.GlobalStatTcpLast.NumConnClosedPS = (float32)(temp.NumConnClosed-s.GlobalStatTcpLast.NumConnClosed) / tdelta
		s.GlobalStatTcpLast.NumConnCreatedPS = (float32)(temp.NumConnCreated-s.GlobalStatTcpLast.NumConnCreated) / tdelta

		// max
		//

		// NumxxLast
		s.GlobalStatTcpLast.NumDBMsgStored = temp.NumDBMsgStored
		s.GlobalStatTcpLast.NumErrorRcv = temp.NumErrorRcv
		s.GlobalStatTcpLast.NumPktsDroped = temp.NumPktsDroped
		s.GlobalStatTcpLast.NumPktsReceived = temp.NumPktsReceived
		s.GlobalStatTcpLast.NumInvalidPkts = temp.NumInvalidPkts
		s.GlobalStatTcpLast.NumConnClosed = temp.NumConnClosed
		s.GlobalStatTcpLast.NumConnCreated = temp.NumConnCreated

		//
		ret, _ = json.Marshal(s.GlobalStatTcpLast)
	default:
		ret = []byte("{\"failed\":true, \"msg\":\"unknown api\"}")

	}
	if w == nil && r == nil {
		// write to database

	} else {
		w.Header().Set("Content-Type", "application/json")
		w.Write(ret)
	}

	log.Debug(string(ret))
}
