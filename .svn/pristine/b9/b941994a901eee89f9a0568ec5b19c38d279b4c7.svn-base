package main

import (
	"encoding/hex"
	"encoding/json"
	. "lbsas/datatypes"
	. "lbsas/vendors/gl500/nbsihai"
	"log"
	"net"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

// globals
var GlobalStatTcp, GlobalStatTcpLast struct {
	NumConnActive, NumConnCreated, NumConnClosed, NumPktsReceived, NumErrorRcv, NumDBMsgStored,
	NumPktsDroped, NumInvalidPkts uint64
	NumConnCreatedPS, NumConnClosedPS, NumPktsReceivedPS, NumErrorRcvPS, NumDBMsgStoredPS,
	NumPktsDropedPS, NumInvalidPktsPS,
	MaxNumConnCreatedPS, MaxNumConnClosedPS, MaxNumPktsReceivedPS, MaxNumErrorRcvPS, MaxNumDBMsgStoredPS,
	MaxNumPktsDropedPS, MaxNumInvalidPktsPS float32
	StartTime, LastTime, NowTime time.Time
}

// main
func TCPServer() {
	log.SetFlags(log.Lshortfile | log.Ldate | log.Ltime)
	// start receiving
	go func() {
		a, e := net.ResolveTCPAddr(GlobalConfigTcp.Protocol, GlobalConfigTcp.Addr)
		if e != nil {
			log.Fatal(e)
		}
		l, e := net.ListenTCP(GlobalConfigTcp.Protocol, a)
		for {
			c, e := l.Accept()
			if e != nil {
				log.Fatal(e)
			}
			// new tcp sock session
			GlobalStatTcp.NumConnCreated++
			log.Println("accepted:", c.RemoteAddr().String())
			go tcpStartSession(c)
		}
	}()

	// code for statistics, just skip these
	GlobalStatTcp.LastTime = time.Now()
	GlobalStatTcp.NowTime = GlobalStatTcp.LastTime
	GlobalStatTcp.StartTime = GlobalStatTcp.LastTime
	GlobalStatTcpLast.LastTime = GlobalStatTcp.LastTime
	GlobalStatTcpLast.NowTime = GlobalStatTcp.LastTime
	GlobalStatTcpLast.StartTime = GlobalStatTcp.LastTime

	// start the embedded web server
	r := mux.NewRouter()
	r.HandleFunc("/api/{component}", _apiHandlerTcp)
	http.Handle("/", r)
	go http.ListenAndServe("127.0.0.1:9090", nil)
}

// tcp session handler
func tcpStartSession(conn net.Conn) {
	defer conn.Close()

	// channel to cache packets when the far-end device is busy sending
	packetsChan := make(chan *RawTcpPacket, GlobalConfigTcp.ChanSize)
	defer close(packetsChan)

	// create a default worker
	go TcpWorker(packetsChan)

	var (
		last, n int
		whole   bool
		err     error
		buff    []byte
	)

	last, n, err, buff, whole =
		0, 0, nil,
		make([]byte, GlobalConfigTcp.PacketMaxLen), true

	// try to read a packet
	for {
		// set read timeout
		conn.SetReadDeadline(time.Now().Add(GlobalConfigTcp.ReadTimeoutSec * time.Second))
		n, err = conn.Read(buff[last:])
		if err != nil {
			// log.Error(err)
			GlobalStatTcp.NumErrorRcv++
			break
		}

		if last == 0 && buff[0] != GlobalConfigTcp.StartSymbol {
			// invalid packet
			GlobalStatTcp.NumInvalidPkts++

			// TODO: there are two approches here:
			// 1) ignor and continue
			// 2) refuse and close
			// we chose the 2nd one
			//continue
			err = ErrorMessage["INVALID_PACKET_HT"]
			break
		}

		// TODO: [remove me] for test with netcat/telnet
		if buff[last+n-1] == 0x0a {
			buff[last+n-1] = 0
			n--
			if n == 0 {
				continue
			}
		}

		log.Println(string(buff[:last+n]), "decoded:", hex.EncodeToString(buff[:last+n]))

		// there is remain part unread
		whole, err = IsWholePacket(buff[last:last+n], &whole)
		if err != nil {
			GlobalStatTcp.NumInvalidPkts++
			// Invalid packet
			break
		} else if !whole {
			last += n
			// TODO: remove me
			log.Println("not whole packet:", string(buff[:last]))
		} else {
			// we got a whole packet here
			GlobalStatTcp.NumPktsReceived++
			packet := &RawTcpPacket{make([]byte, last+n), &conn}
			copy(packet.Buff, buff[:last+n])
			// reset counters
			n, last, whole = 0, 0, true

			// insert into the chan
			select {
			case packetsChan <- packet:
				log.Println("new chan elem:", string(packet.Buff), ", from:", (*packet.Conn).RemoteAddr().String())
			default:
				// TODO: two approches to handle this situation
				// 1) just drop the oldest msg and insert the new one
				// 2) create a now worker on the channel and insert again
				// Currently the first one is applied; the second approche can
				// be a feature in future release, and it's required
				// to release long-time-ide workers [IMPORTANT feature]

				<-packetsChan
				packetsChan <- packet
				GlobalStatTcp.NumPktsDroped++
				// TODO
				log.Println("Buff overflow in :%#v", conn)
			}
		}
	}

	// teardown
	if err != nil {
		//TODO
		log.Println(err)
	}
	GlobalStatTcp.NumConnClosed++
}

// code for statistics, just skip it
func _apiHandlerTcp(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	coapi := vars["component"]
	var ret []byte
	switch coapi {
	case "tcpstatus":
		temp := GlobalStatTcp

		GlobalStatTcpLast.LastTime = GlobalStatTcpLast.NowTime
		GlobalStatTcpLast.NowTime = time.Now()
		// NxxPS
		tdelta := float32(GlobalStatTcpLast.NowTime.Unix() - GlobalStatTcpLast.LastTime.Unix())
		GlobalStatTcpLast.NumDBMsgStoredPS = (float32)(temp.NumDBMsgStored-GlobalStatTcpLast.NumDBMsgStored) / tdelta
		GlobalStatTcpLast.NumErrorRcvPS = (float32)(temp.NumErrorRcv-GlobalStatTcpLast.NumErrorRcv) / tdelta
		GlobalStatTcpLast.NumPktsDropedPS = (float32)(temp.NumPktsDroped-GlobalStatTcpLast.NumPktsDroped) / tdelta
		GlobalStatTcpLast.NumPktsReceivedPS = (float32)(temp.NumPktsReceived-GlobalStatTcpLast.NumPktsReceived) / tdelta
		GlobalStatTcpLast.NumInvalidPktsPS = (float32)(temp.NumInvalidPkts-GlobalStatTcpLast.NumInvalidPkts) / tdelta
		GlobalStatTcpLast.NumConnClosedPS = (float32)(temp.NumConnClosed-GlobalStatTcpLast.NumConnClosed) / tdelta
		GlobalStatTcpLast.NumConnCreatedPS = (float32)(temp.NumConnCreated-GlobalStatTcpLast.NumConnCreated) / tdelta

		// max
		//

		// NumxxLast
		GlobalStatTcpLast.NumDBMsgStored = temp.NumDBMsgStored
		GlobalStatTcpLast.NumErrorRcv = temp.NumErrorRcv
		GlobalStatTcpLast.NumPktsDroped = temp.NumPktsDroped
		GlobalStatTcpLast.NumPktsReceived = temp.NumPktsReceived
		GlobalStatTcpLast.NumInvalidPkts = temp.NumInvalidPkts
		GlobalStatTcpLast.NumConnClosed = temp.NumConnClosed
		GlobalStatTcpLast.NumConnCreated = temp.NumConnCreated

		//
		ret, _ = json.Marshal(GlobalStatTcpLast)
	default:
		ret = []byte("{\"failed\":true, \"msg\":\"unknown api\"}")

	}
	if w == nil && r == nil {

	} else {
		w.Header().Set("Content-Type", "application/json")
		w.Write(ret)
	}

	log.Println(string(ret))
}
