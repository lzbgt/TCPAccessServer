package nbsihai

import (
	"bytes"
	dbh "lbsas/database"
	dt "lbsas/datatypes"
	"net"
	"strings"

	log "github.com/Sirupsen/logrus"
)

// module exported globals
type NbSiHai struct {
	GlobalConfigTcp dt.TCPCfg
}

func New() *NbSiHai {
	return &NbSiHai{
		dt.TCPCfg{ // flags
			Addr:           "0.0.0.0:8082",
			Protocol:       "tcp",
			ChanSize:       100,
			ReaderNum:      4,
			RetryNum:       3,
			WorkerNum:      2,
			ReadTimeoutSec: 200,
			PacketMaxLen:   180,
			StartSymbol:    '+',
			EndSymbol:      '$',
		},
	}
}

// module private globals
var _MessageConstants = &struct {
	ClassReport, ClassAT, ClassACK, ClassBuff string
	Commands                                  map[string]interface{}
	Delimiter                                 byte
}{
	"RESP:", "AT+", "ACK:", "BUFF:",
	map[string]interface{}{
		"RESP:GTCTN": dt.MessageResp{},
		"RESP:GTSTR": dt.MessageResp{},
		"RESP:GTRTL": dt.MessageResp{},
		"RESP:GTBL":  dt.MessageResp{},
		"BUFF:GTCTN": dt.MessageResp{},
		"BUFF:GTSTR": dt.MessageResp{},
		"BUFF:GTRTL": dt.MessageResp{},
	},
	byte(','),
}

var Dbhelper, DbhelperErr = dbh.New("root:tusung*123@tcp(192.168.1.3:3306)/cargts", log.GetLevel())

func (s *NbSiHai) TcpWorker(packetsChan chan *dt.RawTcpPacket) {
	for {
		packet := <-packetsChan

		// handle channel close event
		if packet == nil {
			log.Info("nil packet, close connection")
			break
		} else {
			// data packet
			if !s.HandlePacket(packet) {
				continue
			}
		}
	}
}

func (s *NbSiHai) HandlePacket(packet *dt.RawTcpPacket) bool {
	buff := packet.Buff[1 : len(packet.Buff)-1]
	if len(buff) == 0 {
		log.Info("invalid packet, ignored")
		return false
	}

	//split
	var sep bytes.Buffer
	sep.WriteByte(s.GlobalConfigTcp.EndSymbol)
	sep.WriteByte(s.GlobalConfigTcp.StartSymbol)
	messages := strings.Split(string(buff), sep.String())

	for _, v := range messages {
		parts := strings.Split(v, string(_MessageConstants.Delimiter))
		s.ParseMessage(parts, packet.Conn)
	}

	return true
}

func (s *NbSiHai) ParseMessage(parts []string, conn *net.Conn) interface{} {
	if par := _MessageConstants.Commands[parts[0]]; par != nil {
		switch par.(type) {
		case dt.MessageResp:
			_par := par.(dt.MessageResp)
			_par.Parse(parts, conn)
		default:
			log.Error("unkown message", parts, "From", (*conn).RemoteAddr().String())
		}
	} else {
		log.Error("unkown cmd", parts, "From", (*conn).RemoteAddr().String())
	}

	return nil
}

// helper function
// try to match '+' and '$'
func (s *NbSiHai) IsWholePacket(buff []byte, whole *bool) (bool, error) {
	for i := 0; i < len(buff); i++ {
		switch buff[i] {
		case s.GlobalConfigTcp.StartSymbol:
			if *whole == false {
				return false, dt.ErrorMessage["INVALID_PACKET_HT"]
			}
			*whole = false
		case s.GlobalConfigTcp.EndSymbol:
			if *whole == true {
				return false, dt.ErrorMessage["INVALID_PACKET_HT"]
			}
			*whole = true
		}
	}
	// TODO: is there a '\0' at the end?
	return *whole && buff[len(buff)-1] == s.GlobalConfigTcp.EndSymbol, nil
}

func (s *NbSiHai) GetCfg() *dt.TCPCfg {
	return &(s.GlobalConfigTcp)
}

func (s *NbSiHai) SetLogLevel(lv log.Level) {
	log.SetLevel(lv)
}
